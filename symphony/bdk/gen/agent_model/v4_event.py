# coding: utf-8

"""
    Agent API

    This document refers to Symphony API calls to send and receive messages and content. They need the on-premise Agent installed to perform decryption/encryption of content.  - sessionToken and keyManagerToken can be obtained by calling the authenticationAPI on the symphony back end and the key manager respectively. Refer to the methods described in authenticatorAPI.yaml. - Actions are defined to be atomic, ie will succeed in their entirety or fail and have changed nothing. - If it returns a 40X status then it will have sent no message to any stream even if a request to some subset of the requested streams would have succeeded. - If this contract cannot be met for any reason then this is an error and the response code will be 50X. - MessageML is a markup language for messages. See reference here: https://rest-api.symphony.com/docs/messagemlv2 - **Real Time Events**: The following events are returned when reading from a real time messages and events stream (\"datafeed\"). These events will be returned for datafeeds created with the v5 endpoints. To know more about the endpoints, refer to Create Messages/Events Stream and Read Messages/Events Stream. Unless otherwise specified, all events were added in 1.46. 

    The version of the OpenAPI document: 24.12.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from symphony.bdk.gen.agent_model.v4_initiator import V4Initiator
from symphony.bdk.gen.agent_model.v4_payload import V4Payload
from typing import Optional, Set
from typing_extensions import Self

class V4Event(BaseModel):
    """
    V4Event
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Event ID")
    message_id: Optional[StrictStr] = Field(default=None, description="Message ID", alias="messageId")
    timestamp: Optional[StrictInt] = Field(default=None, description="Timestamp of event")
    type: Optional[StrictStr] = Field(default=None, description="Event type, possible events are:   - MESSAGESENT   - SHAREDPOST   - INSTANTMESSAGECREATED   - ROOMCREATED   - ROOMUPDATED   - ROOMDEACTIVATED   - ROOMREACTIVATED   - USERJOINEDROOM   - USERLEFTROOM   - ROOMMEMBERPROMOTEDTOOWNER   - ROOMMEMBERDEMOTEDFROMOWNER   - CONNECTIONREQUESTED   - CONNECTIONACCEPTED   - MESSAGESUPPRESSED   - SYMPHONYELEMENTSACTION   - USERREQUESTEDTOJOINROOM   - GENERICSYSTEMEVENT ")
    diagnostic: Optional[StrictStr] = Field(default=None, description="Details if event failed to parse for any reason.  The contents of this field may not be useful, depending on the nature of the error. Only present when error occurs. ")
    initiator: Optional[V4Initiator] = None
    payload: Optional[V4Payload] = None
    __properties: ClassVar[List[str]] = ["id", "messageId", "timestamp", "type", "diagnostic", "initiator", "payload"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of V4Event from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of initiator
        if self.initiator:
            _dict['initiator'] = self.initiator.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payload
        if self.payload:
            _dict['payload'] = self.payload.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of V4Event from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "messageId": obj.get("messageId"),
            "timestamp": obj.get("timestamp"),
            "type": obj.get("type"),
            "diagnostic": obj.get("diagnostic"),
            "initiator": V4Initiator.from_dict(obj["initiator"]) if obj.get("initiator") is not None else None,
            "payload": V4Payload.from_dict(obj["payload"]) if obj.get("payload") is not None else None
        })
        return _obj


